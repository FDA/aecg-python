<?xml version="1.0" encoding="UTF-8"?>
<!--
    This schema is generated from a Generic Schema Definition (GSD)
    by gsd2xsl. Better not edit this file.
  -->
<xs:schema
		targetNamespace="urn:hl7-org:v3"
		xmlns="urn:hl7-org:v3"
		xmlns:hl7="urn:hl7-org:v3"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		elementFormDefault="qualified"
		version="dmn:2003-05-11">
	<xs:annotation>
		<xs:documentation>
		      2003-12-11: vdp removed the EC abstract type; added generics to
		      accomodate the CDA schema needs.
			2003-10-02: pvb: this schema has been hand edited...starting from v=dmn:2003-05-11.
			It is intended only as an interim version of datatypes.xsd.  It is NOT an official
			version.  The intention of the edits are to make this schema acceptable to
			xjc v1.0.1.
			
			The main change is the introduction of EC, EAXP, EEXP and CDR abstract
			types...see the xs:documentation for EC and SC for more details.  This
			change will hopefully only be necessary on a short term basis, as xjc is
			supposed to be corrected in its next version to handle the normal
			derivations that we have and this change will be backed out when that
			happens.
			
			Another recent change is in uid and the new OID type...necessary for
			support of RIM class InfrastructureRoot.templateId.  This one is intended
			to be incorporated into the final datatypes.xsd.  See the xs:documentation
			there for more details.
			
			I have also added instantiations of all generic types used in the RIM...this
			is also likely to be incorporated into the final datatypes.xsd.
			
			I'm afraid I may have also made a few other edits to this file without
			documenting them...if you notice any differences please bring them to
			my attention.
		</xs:documentation>
	</xs:annotation>
	<xs:element name='foo' type='SC'/>
	<xs:attributeGroup name="ANY">
		<xs:annotation>
			<xs:documentation>
			Defines the basic properties of every data value. This is an abstract
			type, meaning that no value can be just a data value without belonging
			to any concrete type. Every concrete type is a specialization of this
			general abstract DataValue type.
		  </xs:documentation>
		</xs:annotation>
		<xs:attribute name="nullFlavor" type="cs_NullFlavor" use="optional">
			<xs:annotation>
				<xs:documentation>
				An exceptional value expressing missing information and possibly the
				reason why the information is missing.
		  </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!--
		<xs:attribute name="id" type="xs:ID" use="optional"/>
		<xs:attribute name="idref" type="xs:IDREF" use="optional"/>
		-->
	</xs:attributeGroup>
	<xs:simpleType name="cs_NullFlavor">
		<xs:restriction base="cs">
			<xs:enumeration value="NI"/>
			<xs:enumeration value="NA"/>
			<xs:enumeration value="UNK"/>
			<xs:enumeration value="NASK"/>
			<xs:enumeration value="ASKU"/>
			<xs:enumeration value="NAV"/>
			<xs:enumeration value="OTH"/>
			<xs:enumeration value="PINF"/>
			<xs:enumeration value="NINF"/>
			<xs:enumeration value="MSK"/>
			<xs:enumeration value="NP"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="bl">
		<xs:annotation>
			<xs:documentation>
		   The Boolean type stands for the values of two-valued logic. A
		   Boolean value can be either true or
		   false, or, as any other value may be NULL.
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:boolean">
			<xs:pattern value="true|false"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="BL">
		<xs:annotation>
			<xs:documentation>
		   The Boolean type stands for the values of two-valued logic. A
		   Boolean value can be either true or
		   false, or, as any other value may be NULL.
		</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="(@nullFlavor or @value) and not(@nullFlavor and @value)">
					<p>
				Although the use of the value is optional, the
				constraint (expressed as an XPath predicate), specifies that there
				must be either an value or the
				 attribute, but not both.
				</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="value" type="bl" use="optional"/>
	</xs:complexType>
	<xs:simpleType name="bin">
		<xs:annotation>
			<xs:documentation>
			Binary data is a raw block of bits. Binary data is a protected
			type that should not be declared outside the data type specification.
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:base64Binary"/>
	</xs:simpleType>
	<xs:simpleType name="cs_BinaryDataEncoding">
		<xs:restriction base="xs:NMTOKEN">
			<xs:enumeration value="B64"/>
			<xs:enumeration value="TXT"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="BIN" mixed="true">
		<xs:annotation>
			<xs:documentation>
		Binary data is a raw block of bits. Binary data is a protected
		type that should not be declared outside the data type specification.
		</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="encoding" type="cs_BinaryDataEncoding" use="optional" default="TXT">
			<xs:annotation>
				<xs:documentation>
				Specifies the encoding of the binary data that is the content
				of the binary data complex XML schema data type.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="cs_CompressionAlgorithm">
		<xs:restriction base="cs">
			<xs:enumeration value="DF"/>
			<xs:enumeration value="GZ"/>
			<xs:enumeration value="ZL"/>
			<xs:enumeration value="Z"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_IntegrityCheckAlgorithm">
		<xs:restriction base="cs">
			<xs:enumeration value="SHA-1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ED_no_tn" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="reference" type="TEL" minOccurs="0"/>
					<xs:element name="thumbnail" type="ED_no_tn" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ED" mixed="true">
		<xs:annotation>
			<xs:documentation>
			Data that is primarily intended for human interpretation or for
			further machine processing is outside the scope of HL7. This includes
			unformatted or formatted written language, multimedia data, or
			structured information as defined by a different standard (e.g.,
			XML-signatures.)  Instead of the data itself, an ED may contain only
			a reference (see TEL.) Note that the ST data type is a specialization
			of the ED data type when the ED media type is text/plain.
		</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="count(node()[not(self::reference or self::thumbnail)])&lt;=1">
					<p>
               	ED (and its restricted form, ST) are encoded as character data,
               	resulting in a mixed content model for ED.  Because of this mixed
				content model, the text content could be split into several text
				nodes. Only XML encodings are valid that produce at most one text
				node.
				</p>
				</hl7:pr>
				<hl7:pr assert="(@nullFlavor or text()) and not(@nullFlavor and text())">
					<p>Text content is only allowed in non-NULL values.</p>
				</hl7:pr>
				<hl7:pr assert="(@nullFlavor or @type) and not(@nullFlavor and @type)">
					<p>The media type attribute is only allowed for non-NULL values.</p>
				</hl7:pr>
				<hl7:pr assert="(@nullFlavor or @integrityCheck) and not(@nullFlavor and @integrityCheck)"/>
				<hl7:pr assert="(@integrityCheckAlgorithm and @integrityCheck) or not(@integrityCheckAlgorithm or @integrityCheck)"/>
				<hl7:pr assert="(@nullFlavor or @reference) and not(@nullFlavor and @reference)"/>
				<hl7:pr assert="(@nullFlavor or @thumbnail) and not(@nullFlavor and @thumbnail)"/>
				<hl7:pr assert="(@nullFlavor or @type) and not(@nullFlavor and @type)"/>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="BIN">
				<xs:sequence>
					<xs:element name="reference" type="TEL" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
						A telecommunication address (TEL), such as a URL for HTTP or FTP,
						which will resolve to precisely the same binary data that could as
						well have been provided as inline data.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="thumbnail" type="ED_no_tn" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
					A thumbnail is an abbreviated rendition of the full data. A thumbnail
					requires significantly fewer resources than the full data, while still
					maintaining some distinctive similarity with the full data. A
					thumbnail is typically used with by-reference encapsulated data. It
					allows a user to select data more efficiently before actually
					downloading through the reference.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="mediaType" type="cs" use="optional" default="text/plain">
					<xs:annotation>
						<xs:documentation>
					Identifies the encoding of the encapsulated data and identifies a
					method to interpret or render the data.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="compression" type="cs_CompressionAlgorithm" use="optional">
					<xs:annotation>
						<xs:documentation>
					Indicates whether the raw byte data is compressed, and what
					compression algorithm was used.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="integrityCheck" type="bin" use="optional">
					<xs:annotation>
						<xs:documentation>
					The integrity check is a short binary value representing a
					cryptographically strong checksum that is calculated over the binary
					data. The purpose of this property, when communicated with a reference
					is for anyone to validate later whether the reference still resolved
					to the same data that the reference resolved to when the encapsulated
					data value with reference was created.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="integrityCheckAlgorithm" type="cs_IntegrityCheckAlgorithm" use="optional" fixed="SHA-1">
					<xs:annotation>
						<xs:documentation>
					Specifies the algorithm used to compute the integrityCheck value.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
<!--	<xs:complexType name='EC' mixed='true' abstract='true'>
		<xs:annotation>
		  <xs:documentation>
		  	2003-10-02: pvb: this type does not exist in Abstract Data Types, and has
		  	not appeared in any previous datatypes.xsd or XML ITS: Data Types ballot.
		  	However, do to a limitation in the v0.9 draft of the JAXB spec, a JAXB compiler
		  	can't handle a restriction followed by an extension (as in ED -r- > ST -e- > SC).
		  	Therefore, as a short term workaround, I am introducing this here (so that
		  	SC can be derived by restriction from it, as in ED -e- > EC -r- > SC)
		  	to make JAXB compilers happy.
		  	
		  	Note: this type is defined as an 'abstract' so it cannot be used as the
		  	type of an element in an instance.  Also, this introduction does not change
		  	the set of valid instances and only changes the type hierarchy (as exposed
		  	thru PSVI or programming language classes produced data binding tools)
		  	slightly, particular:
		  	
		  		SC obj = new SC () ;
		  		if (obj instanceof ED) {
		  			/* is true */
		  			}
		  	in both hierarchies
		  	
		  	I am working on trying to get JAXB changed to allow this before it
		  	goes final and then we can back this change out (if we're not already
		  	final).
		  </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base='ED'>
				<xs:attribute name="code" type="cs" use="optional">
					<xs:annotation>
						<xs:documentation>
							The plain code symbol defined by the code system. For example,
							"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystem" type="uid" use="optional">
					<xs:annotation>
						<xs:documentation>
						Specifies the code system that defines the code.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystemName" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
							A common name of the coding system.
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystemVersion" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
							If applicable, a version descriptor defined specifically for the given
							code system
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="displayName" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
						A name or title for the code, under which the sending system shows the
						code value to its users.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType> -->
	<xs:simpleType name="st">
		<xs:annotation>
			<xs:documentation>
			The character string data type stands for text data, primarily
			intended for machine processing (e.g., sorting, querying, indexing,
			etc.) Used for names, symbols, and formal expressions.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:complexType name="ST" mixed="true">
		<xs:annotation>
			<xs:documentation>
			The character string data type stands for text data, primarily
			intended for machine processing (e.g., sorting, querying, indexing,
			etc.) Used for names, symbols, and formal expressions.
			</xs:documentation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
			</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="(@nullFlavor or text()) and not(@nullFlavor and text())">
					<p>Text content is only allowed in non-NULL values.</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base="ED">
				<xs:sequence>
					<xs:element name="reference" type="TEL" minOccurs="0" maxOccurs="0"/>
					<xs:element name="thumbnail" type="ED_no_tn" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="encoding" type="cs_BinaryDataEncoding" use="prohibited" fixed="TXT"/>
				<xs:attribute name="mediaType" type="cs" use="prohibited" fixed="text/plain"/>
				<xs:attribute name="compression" type="cs_CompressionAlgorithm" use="prohibited"/>
				<xs:attribute name="integrityCheck" type="bin" use="prohibited"/>
				<xs:attribute name="integrityCheckAlgorithm" type="cs_IntegrityCheckAlgorithm" use="prohibited" fixed="SHA-1"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs">
		<xs:annotation>
			<xs:documentation>
		Coded data in its simplest form, consists of a code and display name.
		The code system and code system version is fixed by the context in
		which the CS value occurs. CS is used for coded attributes that have a
		single HL7-defined value set.
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:pattern value="[^\s]*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="CD">
		<xs:annotation>
			<xs:documentation>
		A concept descriptor represents any kind of concept usually by
		giving a code defined in a code system. A concept descriptor can
		contain the original text or phrase that served as the basis of
		the coding and one or more translations into different coding systems.
		A concept descriptor can also contain qualifiers to describe, e.g., the
		concept of a "left foot" as a postcoordinated term built from the
		primary code "FOOT" and the qualifier "LEFT". In exceptional cases,
		the concept descriptor need not contain a code but only the original
		text describing that concept.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
					Specifies additional codes that increase the specificity of the the
					primary code.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="originalText" type="ED" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					The text or phrase used as the basis for the coding.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
					A set of other concept descriptors that translate this concept
					descriptor into other code systems.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="code" type="cs" use="optional">
			<xs:annotation>
				<xs:documentation>
					The plain code symbol defined by the code system. For example,
					"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="codeSystem" type="uid" use="optional">
			<xs:annotation>
				<xs:documentation>
				Specifies the code system that defines the code.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="codeSystemName" type="st" use="optional">
			<xs:annotation>
				<xs:documentation>
					A common name of the coding system.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="codeSystemVersion" type="st" use="optional">
			<xs:annotation>
				<xs:documentation>
					If applicable, a version descriptor defined specifically for the given
					code system
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="displayName" type="st" use="optional">
			<xs:annotation>
				<xs:documentation>
				A name or title for the code, under which the sending system shows the
				code value to its users.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CE">
		<xs:annotation>
			<xs:documentation>
			Coded data, consists of a coded value (CV) and, optionally, coded
			value(s) from other coding systems that identify the same
			concept. Used when alternative codes may exist.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD">
				<xs:sequence>
					<xs:element name="originalText" type="ED" minOccurs="0"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="0"/>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CV">
		<xs:annotation>
			<xs:documentation>
		Coded data, consists of a code, display name, code system, and
		original text. Used when a single code value must be sent.
		</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD">
				<xs:sequence>
					<xs:element name="originalText" type="ED" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
						The text or phrase used as the basis for the coding.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>
					A set of other concept descriptors that translate this concept
					descriptor into other code systems.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CS">
		<xs:annotation>
			<xs:documentation>
		Coded data, consists of a code, display name, code system, and
		original text. Used when a single code value must be sent.
		</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="CD">
				<xs:sequence>
					<xs:element name="originalText" type="ED" minOccurs="0" maxOccurs="0"/>
					<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="0"/>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="codeSystem" type="uid" use="prohibited"/>
				<xs:attribute name="codeSystemName" type="st" use="prohibited"/>
				<xs:attribute name="codeSystemVersion" type="st" use="prohibited"/>
				<xs:attribute name="displayName" type="st" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CR">
		<xs:annotation>
			<xs:documentation>
			A concept qualifier code with optionally named role.  Both qualifier
			role and value codes must be defined by the coding system.  For
			example, if SNOMED RT defines a concept "leg", a role relation
			"has-laterality", and another concept "left", the concept role
			relation allows to add the qualifier "has-laterality: left" to a
			primary code "leg" to construct the meaning "left leg".
			</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="(value or @nullFlavor) and not(@nullFlavor and node())">
					<p>A value component is required or else the code role is NULL.</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CD">
				<xs:sequence>
					<xs:element name="name" type="CV" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
					Specifies the manner in which the concept role value contributes to
					the meaning of a code phrase.  For example, if SNOMED RT defines a
					concept "leg", a role relation "has-laterality", and another concept
					"left", the concept role relation allows to add the qualifier
					"has-laterality: left" to a primary code "leg" to construct the
					meaning "left leg".  In this example "has-laterality" is the CR.name.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="value" type="CD" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
					The concept that modifies the primary code of a code phrase through
					the role relation.  For example, if SNOMED RT defines a concept "leg",
					a role relation "has-laterality", and another concept "left", the
					concept role relation allows adding the qualifier "has-laterality:
					left" to a primary code "leg" to construct the meaning "left leg".  In
					this example "left" is the CR.value.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="inverted" type="bl" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>
					Indicates if the sense of the role name is inverted.  This can be used
					in cases where the underlying code system defines inversion but does
					not provide reciprocal pairs of role names. By default, inverted is
					false.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SC" mixed="true">
		<xs:annotation>
			<xs:documentation>
			A Character String that optionally
			may have a code attached. The text must always be present if a code is
			present. The code is often a local code.
		  </xs:documentation>
		  <xs:documentation>
		  	2003-10-02: pvb: this type was previously an extension of ST.  However,
		  	do to a limitation in the v0.9 draft of the JAXB spec, a JAXB compiler
		  	can't handle a restriction followed by an extension (as in ED -r->ST -e-> SC).
		  	Therefore, as a short term work around, I am changing this as here
		  	to make JAXB compilers happy.
		  	
		  	Note: this does not change the set of valid instances and only changes
		  	the type hierarchy (as exposed thru PSVI or data binding tools) slightly,
		  	particular:
		  	
		  		SC obj = new SC () ;
		  		if (obj instanceof ED) {
		  			/* is true */
		  			}
		  	in both hierarchies
		  	
		  	I am working on trying to get JAXB changed to allow this before it
		  	goes final and then we can back this change out (if we're not already
		  	final).
		  </xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="ST">
				<!-- <xs:attribute name="mediaType" type="cs" use="optional" fixed="text/plain"/> -->
				<xs:attribute name="compression" type="cs_CompressionAlgorithm" use="prohibited"/>
				<xs:attribute name="integrityCheck" type="bin" use="prohibited"/>
				<xs:attribute name="integrityCheckAlgorithm" type="cs_IntegrityCheckAlgorithm" use="prohibited" fixed="SHA-1"/>
				<xs:attribute name="code" type="cs" use="optional">
					<xs:annotation>
						<xs:documentation>
							The plain code symbol defined by the code system. For example,
							"784.0" is the code symbol of the ICD-9 code "784.0" for headache.
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystem" type="uid" use="optional">
					<xs:annotation>
						<xs:documentation>
						Specifies the code system that defines the code.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystemName" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
							A common name of the coding system.
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="codeSystemVersion" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
							If applicable, a version descriptor defined specifically for the given
							code system
							</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="displayName" type="st" use="optional">
					<xs:annotation>
						<xs:documentation>
						A name or title for the code, under which the sending system shows the
						code value to its users.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="oid">
		<xs:restriction base="xs:string">
			<xs:pattern value="([1-9][0-9]*)(\.[1-9][0-9]*)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="uuid">
		<xs:restriction base="xs:string">
			<xs:pattern value="[0-9a-zA-Z]{8}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{12}"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ruid">
		<xs:annotation>
			<xs:documentation source='http://www.w3.org/2001/05/xmlschema-errata#e2-18'>
				2003-10-02: pvb: the 3rd pattern might be rejected by *some* schema
				processors although it is correct, per errata e2-18.  Without
				the "\-" at the end, then the current version of many/most of the
				foundation schema processors (such as xerces/msxml/etc) will
				complain, because they have been updated to implement the errata.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Za-z][A-Za-z0-9\-]*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="uid">
		<xs:annotation>
			<xs:documentation>
				2003-10-02: pvb: this type has changed to a union of the 3 types
				specified in the abstract spec...to make for more information
				available at the PSVI level...which has meant the introduction
				of the oid, uuid and ruid types above
			</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes='oid uuid ruid'/>
	</xs:simpleType>
	<xs:complexType name='OID'>
		<xs:attribute name='value' type='uid'/>
		<xs:attributeGroup ref='ANY'/>
	</xs:complexType>
	<xs:simpleType name="ts">
		<xs:annotation>
			<xs:documentation>
			A quantity specifying a point on the axis of natural time. A point
			in time is most often represented as a calendar expression.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<!-- original ballot sequence is inccorrect [+-] The following pattern should escape the +, - , as [+\-] for time zone, but some valdiators complain. 
			      Setting more liberal -->
			<xs:pattern value="[0-9]{1,8}|([0-9]{9,14}|[0-9]{14,14}\.[0-9]+)([+\-][0-9]{1,4})?"/>
		<!--	<xs:pattern value="[0-9]{1,14}(\.[0-9]+)?.*"/> -->
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="TS">
		<xs:annotation>
			<xs:documentation>
			A quantity specifying a point on the axis of natural time. A point
			in time is most often represented as a calendar expression.
			</xs:documentation>
			<xs:appinfo>
				<diff>PQ</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="ts" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="II">
		<xs:annotation>
			<xs:documentation>
			An identifier that uniquely identifies a thing or object. Examples
			are object identifier for HL7 RIM objects, medical record number,
			order id, service catalog item id, Vehicle Identification Number
			(VIN), etc. Instance identifiers are defined based on ISO object
			identifiers.
			</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="(@root or @nullFlavor) and not(@root and @nullFlavor)"/>
			</xs:appinfo>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="validTime" type="IVL_TS" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					If applicable, specifies during what time the identifier is valid. By
					default, the identifier is valid indefinitely. Any specific interval
					may be undefined on either side indicating unknown effective or expiry
					time.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="root" type="uid" use="optional">
			<xs:annotation>
				<xs:documentation>
					A unique identifier that guarantees the global uniqueness of the
					instance identifier. The root alone may be the entire instance
					identifier.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="extension" type="st" use="optional">
			<xs:annotation>
				<xs:documentation>
					A character string as a unique identifier within the scope of the
					identifier root.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="displayable" type="bl" use="optional">
			<xs:annotation>
				<xs:documentation>
					Specifies if the identifier's extension  is intendended for human
					display and data entry (displayable = true) as opposed to pure machine
					interoperation (displayable = false).
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="url">
		<xs:annotation>
			<xs:documentation>
			A telecommunications address  specified according to Internet standard
			RFC 1738  [http://www.isi.edu/in-notes/rfc1738.txt]. The
			URL  specifies the  protocol and  the  contact point  defined by  that
			protocol  for  the resource.  Notable  uses  of the  telecommunication
			address  data  type are  for  telephone  and  telefax numbers,  e-mail
			addresses, Hypertext references, FTP references, etc.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:anyURI"/>
	</xs:simpleType>
	<xs:complexType name="URL">
		<xs:annotation>
			<xs:documentation>
			A telecommunications address  specified according to Internet standard
			RFC 1738  [http://www.isi.edu/in-notes/rfc1738.txt]. The
			URL  specifies the  protocol and  the  contact point  defined by  that
			protocol  for  the resource.  Notable  uses  of the  telecommunication
			address  data  type are  for  telephone  and  telefax numbers,  e-mail
			addresses, Hypertext references, FTP references, etc.
			</xs:documentation>
			<xs:appinfo>
				<hl7:pr assert="(@nullFlavor or @value) and not(@nullFlavor and @value)">
					<p>
				Although the use of the value is optional, the
				constraint (expressed as an XPath predicate), specifies that there
				must be either an value or the
				 attribute, but not both.
				</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="value" type="url" use="optional"/>
	</xs:complexType>
	<xs:simpleType name="cs_TelecommunicationAddressUse">
		<xs:restriction base="cs">
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="AS"/>
			<xs:enumeration value="EC"/>
			<xs:enumeration value="PG"/>
			<xs:enumeration value="MC"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="TEL">
		<xs:annotation>
			<xs:documentation>
			A telephone number (voice or fax), e-mail address, or other locator
			for a resource (information or service) mediated by telecommunication
			equipment. The address is specified as a Universal Resource Locator
			(URL) qualified by time specification and use codes that help in
			deciding which address to use for a given time and purpose.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="URL">
				<xs:sequence>
					<xs:element name="validTime" type="SXCM_TS" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>
					Specifies the periods of time during which the telecommunication
					address can be used.  For a telephone number, this can indicate the
					time of day in which the party can be reached on that telephone.  For
					a web address, it may specify a time range in which the web content is
					promised to be available under the given address.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="use" type="set_cs_TelecommunicationAddressUse" use="optional">
					<xs:annotation>
						<xs:documentation>
					One or more codes advising a system or user which telecommunication
					address in a set of like addresses to select for a given
					telecommunication need.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_AddressPartType">
		<xs:restriction base="cs">
			<xs:enumeration value="DEL"/>
			<xs:enumeration value="CNT"/>
			<xs:enumeration value="STA"/>
			<xs:enumeration value="CPA"/>
			<xs:enumeration value="CTY"/>
			<xs:enumeration value="ZIP"/>
			<xs:enumeration value="STR"/>
			<xs:enumeration value="HNR"/>
			<xs:enumeration value="SAL"/>
			<xs:enumeration value="DIR"/>
			<xs:enumeration value="ADL"/>
			<xs:enumeration value="POB"/>
			<xs:enumeration value="CEN"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name='EAXP' mixed='true' abstract='true'>
		<xs:annotation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
				this type is the equivalent of EC but for ADXP rather than SC
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="ED">
				<xs:attribute name="partType" type="cs_AddressPartType">
					<xs:annotation>
						<xs:documentation>
					Specifies whether an address part names the street, city, country,
					postal code, post box, etc. If the type is NULL the address part is
					unclassified and would simply appear on an address label as is.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ADXP" mixed="true">
		<xs:annotation>
			<xs:documentation>
		A character string that may have a type-tag signifying its role in the
		address. Typical parts that exist in about every address are street,
		house number, or post box, postal code, city, country but other roles
		may be defined regionally, nationally, or on an enterprise level
		(e.g. in military addresses). Addresses are usually broken up into
		lines, which are indicated by special line-breaking delimiter elements
		(e.g., DEL).
		</xs:documentation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base='EAXP'>
				<xs:attribute name="mediaType" type="cs" use="optional" fixed="text/plain"/>
				<xs:attribute name="compression" type="cs_CompressionAlgorithm" use="prohibited"/>
				<xs:attribute name="integrityCheck" type="bin" use="prohibited"/>
				<xs:attribute name="integrityCheckAlgorithm" type="cs_IntegrityCheckAlgorithm" use="prohibited" fixed="SHA-1"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_PostalAddressUse">
		<xs:restriction base="cs">
			<xs:enumeration value="PHYS"/>
			<xs:enumeration value="PST"/>
			<xs:enumeration value="TMP"/>
			<xs:enumeration value="BAD"/>
			<xs:enumeration value="H"/>
			<xs:enumeration value="HP"/>
			<xs:enumeration value="HV"/>
			<xs:enumeration value="WP"/>
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="IDE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="AD" mixed="true">
		<xs:annotation>
			<xs:documentation>
			Mailing and home or office addresses. A sequence of address parts,
			such as street or post office Box, city, postal code, country, etc.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="delimiter">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="DEL"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="country">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="CNT"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="state">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="STA"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="county">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="CPA"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="city">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="CTY"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="postalCode">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="ZIP"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="streetAddressLine">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="SAL"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="streetName">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="STR"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="houseNumber">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="HNR"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="direction">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="DIR"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="additionalLocator">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="ADL"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="postBox">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="POB"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
				</xs:element>
				<xs:element name="censusTract">
					<xs:complexType mixed="true">
						<xs:complexContent mixed="true">
							<xs:restriction base="ADXP">
								<xs:attribute name="partType" type="cs_AddressPartType" fixed="CEN"/>
							</xs:restriction>
						</xs:complexContent>
					</xs:complexType>
					<!-- VOTE: negativ minor: this will not be interoperable because
  there are many census tract definitions. Needs to be coded. This
  should be a location specification (Place class). -->
				</xs:element>
			</xs:choice>
			<xs:element name="validTime" type="SXCM_TS" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						A General Timing Specification (GTS) specifying the periods of
						time during which the address can be used.  This is used to specify
						different addresses for different times of the year or to refer to
						historical addresses.
					  </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="use" type="set_cs_PostalAddressUse" use="optional">
			<xs:annotation>
				<xs:documentation>
					A set of codes advising a system or user which address in a set of
					like addresses to select for a given purpose.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="cs_EntityNamePartQualifier">
		<xs:restriction base="cs">
			<xs:enumeration value="BR"/>
			<xs:enumeration value="SP"/>
			<xs:enumeration value="VV"/>
			<xs:enumeration value="AC"/>
			<xs:enumeration value="PR"/>
			<xs:enumeration value="NB"/>
			<xs:enumeration value="LS"/>
			<xs:enumeration value="CL"/>
			<xs:enumeration value="IN"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name='EEXP' mixed='true' abstract='true'>
		<xs:annotation>
			<xs:documentation>
				see xs:annotation/xs:documentation for ED, EC and SC...this type
				is the equivalent of EC but for ENXP rather than SC
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="ED">
				<xs:attribute name="partType" type="cs_EntityNamePartType">
					<xs:annotation>
						<xs:documentation>
					Indicates whether the name part is a given name, family name, prefix,
					suffix, etc.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="qualifier" type="set_cs_EntityNamePartQualifier" use="optional">
					<xs:annotation>
						<xs:documentation>
					The qualifier is a set of codes each of which specifies a certain
					subcategory of the name part in addition to the main name part type.
					For example, a given name may be flagged as a nickname, a family name
					may be a pseudonym or a name of public records
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ENXP" mixed="true">
		<xs:annotation>
			<xs:documentation>
		A character string token representing a part of a name. May have a
		type code signifying the role of the part in the whole entity name,
		and a qualifier code for more detail about the name part type.
		Typical name parts for person names are given names, and family names,
		titles, etc.
		</xs:documentation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base='EEXP'>
				<xs:attribute name="mediaType" type="cs" use="optional" fixed="text/plain"/>
				<xs:attribute name="compression" type="cs_CompressionAlgorithm" use="prohibited"/>
				<xs:attribute name="integrityCheck" type="bin" use="prohibited"/>
				<xs:attribute name="integrityCheckAlgorithm" type="cs_IntegrityCheckAlgorithm" use="prohibited" fixed="SHA-1"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_EntityNamePartType">
		<xs:restriction base="cs">
			<xs:enumeration value="FAM"/>
			<xs:enumeration value="GIV"/>
			<xs:enumeration value="PFX"/>
			<xs:enumeration value="SFX"/>
			<xs:enumeration value="DEL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_EntityNameUse">
		<xs:restriction base="cs">
			<xs:enumeration value="L"/>
			<xs:enumeration value="A"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="ABC"/>
			<xs:enumeration value="SYL"/>
			<xs:enumeration value="IDE"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="en.del" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ENXP">
				<xs:attribute name="partType" type="cs_EntityNamePartType" fixed="DEL"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="en.fam" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ENXP">
				<xs:attribute name="partType" type="cs_EntityNamePartType" fixed="FAM"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="en.giv" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ENXP">
				<xs:attribute name="partType" type="cs_EntityNamePartType" fixed="GIV"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="en.pfx" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ENXP">
				<xs:attribute name="partType" type="cs_EntityNamePartType" fixed="PFX"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="en.sfx" mixed="true">
		<xs:complexContent mixed="true">
			<xs:restriction base="ENXP">
				<xs:attribute name="partType" type="cs_EntityNamePartType" fixed="SFX"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EN" mixed="true">
		<xs:annotation>
			<xs:documentation>
		A name for a person, organization, place or thing. A sequence of name
		parts, such as first name or family name, prefix, suffix, etc.
		Examples for entity name values are "Jim Bob Walton, Jr.", "Health
		Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
		as a character string or may consist of several entity name parts,
		such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
		"Inc.", "Lake" and "Tahoe".
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="delimiter" type="en.del"/>
				<xs:element name="family" type="en.fam"/>
				<xs:element name="given" type="en.giv"/>
				<xs:element name="prefix" type="en.pfx"/>
				<xs:element name="suffix" type="en.sfx"/>
			</xs:choice>
			<xs:element name="validTime" type="IVL_TS" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accomodates the fact that people change
						names for people, places and things.
					  </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ANY"/>
		<xs:attribute name="use" type="set_cs_EntityNameUse" use="optional">
			<xs:annotation>
				<xs:documentation>
					A set of codes advising a system or user which name in a set of
					like addresses to select for a given purpose.
					A name without specific use code might be a default name
					useful for any purpose, but a name with a specific use code would
					be preferred for that respective purpose.
					</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="cs_PersonNamePartQualifier">
		<xs:restriction base="cs_EntityNamePartQualifier">
			<xs:enumeration value="BR"/>
			<xs:enumeration value="SP"/>
			<xs:enumeration value="VV"/>
			<xs:enumeration value="AC"/>
			<xs:enumeration value="PR"/>
			<xs:enumeration value="NB"/>
			<xs:enumeration value="CL"/>
			<xs:enumeration value="IN"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_PersonNamePartType">
		<xs:restriction base="cs_EntityNamePartType">
			<xs:enumeration value="FAM"/>
			<xs:enumeration value="GIV"/>
			<xs:enumeration value="PFX"/>
			<xs:enumeration value="SFX"/>
			<xs:enumeration value="DEL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="PN" mixed="true">
		<xs:annotation>
			<xs:documentation>
			A name for a person. A sequence of name parts, such as first name or
			family name, prefix, suffix, etc.
		</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base="EN">
				<xs:sequence>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="delimiter">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.del">
										<xs:attribute name="partType" type="cs_PersonNamePartType" fixed="DEL"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="family">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.fam">
										<xs:attribute name="partType" type="cs_PersonNamePartType" fixed="FAM"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="given">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.giv">
										<xs:attribute name="partType" type="cs_PersonNamePartType" fixed="GIV"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="prefix">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.pfx">
										<xs:attribute name="partType" type="cs_PersonNamePartType" fixed="PFX"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="suffix">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.sfx">
										<xs:attribute name="partType" type="cs_PersonNamePartType" fixed="SFX"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
					</xs:choice>
					<xs:element name="validTime" type="IVL_TS" minOccurs="0"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_OrganizationNamePartQualifier">
		<xs:restriction base="cs_EntityNamePartQualifier">
			<xs:enumeration value="LS"/>
			<xs:enumeration value="CL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_OrganizationNamePartType">
		<xs:restriction base="cs_EntityNamePartType">
			<xs:enumeration value="PFX"/>
			<xs:enumeration value="SFX"/>
			<xs:enumeration value="DEL"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ON" mixed="true">
		<xs:annotation>
			<xs:documentation>
			A name for an organization. A sequence of name parts.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base="EN">
				<xs:sequence>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="delimiter">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.del">
										<xs:attribute name="partType" type="cs_OrganizationNamePartType" fixed="DEL"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="prefix">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.pfx">
										<xs:attribute name="partType" type="cs_OrganizationNamePartType" fixed="PFX"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
						<xs:element name="suffix">
							<xs:complexType mixed="true">
								<xs:complexContent mixed="true">
									<xs:restriction base="en.sfx">
										<xs:attribute name="partType" type="cs_OrganizationNamePartType" fixed="SFX"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
					</xs:choice>
					<xs:element name="validTime" type="IVL_TS" minOccurs="0"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TN" mixed="true">
		<xs:annotation>
			<xs:documentation>
			A restriction of entity name that is effectively a simple string used
			for a simple name for things and places.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base="EN">
				<xs:sequence>
					<xs:choice minOccurs="0" maxOccurs="0">
						<xs:element name="delimiter" type="en.del"/>
						<xs:element name="family" type="en.fam"/>
						<xs:element name="given" type="en.giv"/>
						<xs:element name="prefix" type="en.pfx"/>
						<xs:element name="suffix" type="en.sfx"/>
					</xs:choice>
					<xs:element name="validTime" type="IVL_TS" minOccurs="0"/>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QTY" abstract="true">
		<xs:annotation>
			<xs:documentation>
			The quantity data type is an abstract generalization for all data
			types (1) whose value set has an order relation (less-or-equal) and
			(2) where difference is defined in all of the data type's totally
			ordered value subsets.  The quantity type abstraction is needed in
			defining certain other types, such as the interval and the probability
			distribution.
			</xs:documentation>
			<xs:appinfo>
				<diff>QTY</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:simpleType name="int">
		<xs:annotation>
			<xs:documentation>
			Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
			that are results of counting and enumerating. Integer numbers are
			discrete, the set of integers is infinite but countable.  No arbitrary
			limit is imposed on the range of integer numbers. Two NULL flavors are
			defined for the positive and negative infinity.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:integer"/>
	</xs:simpleType>
	<xs:complexType name="INT">
		<xs:annotation>
			<xs:documentation>
			Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
			that are results of counting and enumerating. Integer numbers are
			discrete, the set of integers is infinite but countable.  No arbitrary
			limit is imposed on the range of integer numbers. Two NULL flavors are
			defined for the positive and negative infinity.
			</xs:documentation>
			<xs:appinfo>
				<diff>INT</diff>
				<hl7:pr assert="(@value or @nullFlavor) and not(@value and @nullFlavor)">
					<p>
				Although the use of the value is optional, the constraint
				(expressed as an XPath predicate), specifies that there must be either
				an value or the , but not both.
				</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="int" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="real">
		<xs:annotation>
			<xs:documentation>
		Fractional numbers. Typically used whenever quantities are measured,
		estimated, or computed from other real numbers.  The typical
		representation is decimal, where the number of significant decimal
		digits is known as the precision.
		Real numbers are needed beyond integers whenever quantities of the
		real world are measured, estimated, or computed from other real
		numbers. The term "Real number" in this specification is used to mean
		that fractional values are covered without necessarily implying the
		full set of the mathematical real numbers.
		</xs:documentation>
		</xs:annotation>
		<xs:union memberTypes="xs:decimal xs:double"/>
	</xs:simpleType>
	<xs:complexType name="REAL">
		<xs:annotation>
			<xs:documentation>
			Fractional numbers. Typically used whenever quantities are measured,
			estimated, or computed from other real numbers.  The typical
			representation is decimal, where the number of significant decimal
			digits is known as the precision.
			Real numbers are needed beyond integers whenever quantities of the
			real world are measured, estimated, or computed from other real
			numbers. The term "Real number" in this specification is used to mean
			that fractional values are covered without necessarily implying the
			full set of the mathematical real numbers.
			</xs:documentation>
			<xs:appinfo>
				<diff>REAL</diff>
				<hl7:pr assert="(@nullFlavor or @value) and not(@nullFlavor and @value)">
					<p>
				Although the use of the value is optional, the
				constraint (expressed as an XPath predicate), specifies that there
				must be either a value or the
				, but not both.
				</p>
				</hl7:pr>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="real" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name='CDR' abstract='true'>
		<xs:annotation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
				this type is the equivalent of EC but for PQR rather than SC
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CD">
				<xs:attribute name="value" type="real" use="optional">
					<xs:annotation>
						<xs:documentation>
				The magnitude of the measurement value in terms of the unit
				specified in the code.
				</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQR">
		<xs:annotation>
			<xs:documentation>
			A representation of a physical quantity in a unit from any code
			system. Used to show alternative representation for a physical
			quantity.
			</xs:documentation>
			<xs:documentation>
				2003-10-02: pvb: see xs:annotation/xs:documentation for ED, EC and SC...
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base='CDR'>
				<xs:sequence>
					<xs:element name="originalText" type="ED" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
						The text or phrase used as the basis for the coding.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>
					A set of other concept descriptors that translate this concept
					descriptor into other code systems.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQ">
		<xs:annotation>
			<xs:documentation>
			A dimensioned quantity expressing the result of a measurement act.
		  </xs:documentation>
			<xs:appinfo>
				<diff>PQ</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" type="real" use="optional">
					<xs:annotation>
						<xs:documentation>
					The magnitude of the quantity measured in terms of the unit.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="unit" type="cs" use="optional" default="1">
					<xs:annotation>
						<xs:documentation>
					The unit of measure specified in the Unified Code for Units of Measure
					(UCUM) [http://aurora.rg.iupui.edu/UCUM].
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MO">
		<xs:annotation>
			<xs:documentation>
			A monetary amount is a quantity expressing the amount of money in some
			currency. Currencies are the units in which monetary amounts are
			denominated in different economic regions. While the monetary amount
			is a single kind of quantity (money) the exchange rates between the
			different units are variable.  This is the principle difference
			between physical quantity and monetary amounts, and the reason why
			currency units are not physical units.
			</xs:documentation>
			<xs:appinfo>
				<diff>MO</diff>
				<hl7:pr assert="not(@nullFlavor and (@value or @currency))"/>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:attribute name="value" type="real" use="optional">
					<xs:annotation>
						<xs:documentation>
					The magnitude of the monetary amount in terms of the currency unit.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="currency" type="cs_Currency" use="optional">
					<xs:annotation>
						<xs:documentation>
					The currency unit as defined in ISO 4217.
					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_Currency">
		<xs:restriction base="cs">
			<xs:enumeration value="ARS"/>
			<xs:enumeration value="AUD"/>
			<xs:enumeration value="ATS"/>
			<xs:enumeration value="BEF"/>
			<xs:enumeration value="BRL"/>
			<xs:enumeration value="CAD"/>
			<xs:enumeration value="CLF"/>
			<xs:enumeration value="CNY"/>
			<xs:enumeration value="CUP"/>
			<xs:enumeration value="EUR"/>
			<xs:enumeration value="XEU"/>
			<xs:enumeration value="FIM"/>
			<xs:enumeration value="FRF"/>
			<xs:enumeration value="DEM"/>
			<xs:enumeration value="INR"/>
			<xs:enumeration value="ILS"/>
			<xs:enumeration value="JPY"/>
			<xs:enumeration value="KRW"/>
			<xs:enumeration value="LUF"/>
			<xs:enumeration value="MXN"/>
			<xs:enumeration value="NLG"/>
			<xs:enumeration value="NZD"/>
			<xs:enumeration value="NOK"/>
			<xs:enumeration value="PHP"/>
			<xs:enumeration value="RUR"/>
			<xs:enumeration value="SGD"/>
			<xs:enumeration value="ZAR"/>
			<xs:enumeration value="ESP"/>
			<xs:enumeration value="SEK"/>
			<xs:enumeration value="CHF"/>
			<xs:enumeration value="THB"/>
			<xs:enumeration value="TWD"/>
			<xs:enumeration value="TRL"/>
			<xs:enumeration value="GBP"/>
			<xs:enumeration value="USD"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="RTO" abstract="true">
		<xs:annotation>
			<xs:documentation>
			A quantity constructed as the quotient of a numerator quantity divided
			by a denominator quantity. Common factors in the numerator and
			denominator are not automatically cancelled out.  The  data
			type supports titers (e.g., "1:128") and other quantities produced by
			laboratories that truly represent ratios. Ratios are not simply
			"structured numerics", particularly blood pressure measurements
			(e.g. "120/60") are not ratios. In many cases the
			REAL should be used instead of the .
			  </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RTO_QTY_QTY"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="cs_SetOperator">
		<xs:restriction base="cs">
			<xs:enumeration value="I"/>
			<xs:enumeration value="E"/>
			<xs:enumeration value="A"/>
			<xs:enumeration value="H"/>
			<xs:enumeration value="P"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_ProbabilityDistributionType">
		<xs:restriction base="cs">
			<xs:enumeration value="U"/>
			<xs:enumeration value="N"/>
			<xs:enumeration value="LN"/>
			<xs:enumeration value="G"/>
			<xs:enumeration value="E"/>
			<xs:enumeration value="X2"/>
			<xs:enumeration value="T"/>
			<xs:enumeration value="F"/>
			<xs:enumeration value="B"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_CalendarCycle">
		<xs:restriction base="cs">
			<xs:enumeration value="CY"/>
			<xs:enumeration value="MY"/>
			<xs:enumeration value="CM"/>
			<xs:enumeration value="CW"/>
			<xs:enumeration value="WY"/>
			<xs:enumeration value="DM"/>
			<xs:enumeration value="CD"/>
			<xs:enumeration value="DY"/>
			<xs:enumeration value="DW"/>
			<xs:enumeration value="HD"/>
			<xs:enumeration value="CH"/>
			<xs:enumeration value="NH"/>
			<xs:enumeration value="CN"/>
			<xs:enumeration value="SN"/>
			<xs:enumeration value="CS"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="cs_TimingEvent">
		<xs:restriction base="cs">
			<xs:enumeration value="AC"/>
			<xs:enumeration value="ACD"/>
			<xs:enumeration value="ACM"/>
			<xs:enumeration value="ACV"/>
			<xs:enumeration value="HS"/>
			<xs:enumeration value="IC"/>
			<xs:enumeration value="ICD"/>
			<xs:enumeration value="ICM"/>
			<xs:enumeration value="ICV"/>
			<xs:enumeration value="PC"/>
			<xs:enumeration value="PCD"/>
			<xs:enumeration value="PCM"/>
			<xs:enumeration value="PCV"/>
		</xs:restriction>
	</xs:simpleType>
	<!--
      Instantiated templates
    -->
	<xs:complexType name="TS_inc">
		<xs:complexContent>
			<xs:extension base="TS">
				<xs:attribute name="inclusive" type="bl" use="optional" default="true">
					<xs:annotation>
						<xs:documentation>
					Specifies whether the high limit is included in the interval
					(interval is closed) or excluded from the interval (interval is open).
                  </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_TS">
		<xs:complexContent>
			<xs:extension base="SXCM_TS">
				<xs:choice minOccurs="0">
					<xs:sequence>
						<xs:element name="low" type="TS_inc">
							<xs:annotation>
								<xs:documentation>
						The low limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:choice minOccurs="0">
							<xs:element name="width" type="PQ">
								<xs:annotation>
									<xs:documentation>
							The difference between high and low boundary. The purpose of
							distinguishing a width property is to handle all cases of incomplete
							information symmetrically. In any interval representation only two of
							the three properties high, low, and width need to be stated and the
							third can be derived.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="high" type="TS_inc">
								<xs:annotation>
									<xs:documentation>
							The high limit of the interval.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:sequence>
					<xs:element name="high" type="TS_inc">
						<xs:annotation>
							<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:sequence>
						<xs:element name="width" type="PQ">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="high" type="TS_inc" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:sequence>
						<xs:element name="center" type="TS">
							<xs:annotation>
								<xs:documentation>
							The arithmetic mean of the interval (low plus high divided by 2). The
							purpose of distinguishing the center as a semantic property is for
							conversions of intervals from and to point values.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="width" type="PQ" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SXCM_TS">
		<xs:complexContent>
			<xs:extension base="TS">
				<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I">
					<xs:annotation>
						<xs:documentation>
						A code specifying whether the set component is included (union) or
						excluded (set-difference) from the set, or other set operations with
						the current set component and the set as constructed from the
						representation stream up to the current point.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="INT_inc">
		<xs:complexContent>
			<xs:extension base="INT">
				<xs:attribute name="inclusive" type="bl" use="optional" default="true">
					<xs:annotation>
						<xs:documentation>
					Specifies whether the high limit is included in the interval
					(interval is closed) or excluded from the interval (interval is open).
                  </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_INT">
		<xs:complexContent>
			<xs:extension base="SXCM_INT">
				<xs:choice minOccurs="0">
					<xs:sequence>
						<xs:element name="low" type="INT_inc">
							<xs:annotation>
								<xs:documentation>
						The low limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:choice minOccurs="0">
							<xs:element name="width" type="PQ">
								<xs:annotation>
									<xs:documentation>
							The difference between high and low boundary. The purpose of
							distinguishing a width property is to handle all cases of incomplete
							information symmetrically. In any interval representation only two of
							the three properties high, low, and width need to be stated and the
							third can be derived.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="high" type="INT_inc">
								<xs:annotation>
									<xs:documentation>
							The high limit of the interval.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:sequence>
					<xs:element name="high" type="INT_inc">
						<xs:annotation>
							<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:sequence>
						<xs:element name="width" type="PQ">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="high" type="INT_inc" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:sequence>
						<xs:element name="center" type="INT">
							<xs:annotation>
								<xs:documentation>
							The arithmetic mean of the interval (low plus high divided by 2). The
							purpose of distinguishing the center as a semantic property is for
							conversions of intervals from and to point values.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="width" type="PQ" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SXCM_INT">
		<xs:complexContent>
			<xs:extension base="INT">
				<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I">
					<xs:annotation>
						<xs:documentation>
						A code specifying whether the set component is included (union) or
						excluded (set-difference) from the set, or other set operations with
						the current set component and the set as constructed from the
						representation stream up to the current point.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MO_inc">
		<xs:complexContent>
			<xs:extension base="MO">
				<xs:attribute name="inclusive" type="bl" use="optional" default="true">
					<xs:annotation>
						<xs:documentation>
					Specifies whether the high limit is included in the interval
					(interval is closed) or excluded from the interval (interval is open).
                  </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_MO">
		<xs:complexContent>
			<xs:extension base="SXCM_MO">
				<xs:choice minOccurs="0">
					<xs:sequence>
						<xs:element name="low" type="MO_inc">
							<xs:annotation>
								<xs:documentation>
						The low limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:choice minOccurs="0">
							<xs:element name="width" type="PQ">
								<xs:annotation>
									<xs:documentation>
							The difference between high and low boundary. The purpose of
							distinguishing a width property is to handle all cases of incomplete
							information symmetrically. In any interval representation only two of
							the three properties high, low, and width need to be stated and the
							third can be derived.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="high" type="MO_inc">
								<xs:annotation>
									<xs:documentation>
							The high limit of the interval.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:sequence>
					<xs:element name="high" type="MO_inc">
						<xs:annotation>
							<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:sequence>
						<xs:element name="width" type="PQ">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="high" type="MO_inc" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:sequence>
						<xs:element name="center" type="MO">
							<xs:annotation>
								<xs:documentation>
							The arithmetic mean of the interval (low plus high divided by 2). The
							purpose of distinguishing the center as a semantic property is for
							conversions of intervals from and to point values.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="width" type="PQ" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SXCM_MO">
		<xs:complexContent>
			<xs:extension base="MO">
				<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I">
					<xs:annotation>
						<xs:documentation>
						A code specifying whether the set component is included (union) or
						excluded (set-difference) from the set, or other set operations with
						the current set component and the set as constructed from the
						representation stream up to the current point.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PQ_inc">
		<xs:complexContent>
			<xs:extension base="PQ">
				<xs:attribute name="inclusive" type="bl" use="optional" default="true">
					<xs:annotation>
						<xs:documentation>
					Specifies whether the high limit is included in the interval
					(interval is closed) or excluded from the interval (interval is open).
                  </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IVL_PQ">
		<xs:complexContent>
			<xs:extension base="SXCM_PQ">
				<xs:choice minOccurs="0">
					<xs:sequence>
						<xs:element name="low" type="PQ_inc">
							<xs:annotation>
								<xs:documentation>
						The low limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:choice minOccurs="0">
							<xs:element name="width" type="PQ">
								<xs:annotation>
									<xs:documentation>
							The difference between high and low boundary. The purpose of
							distinguishing a width property is to handle all cases of incomplete
							information symmetrically. In any interval representation only two of
							the three properties high, low, and width need to be stated and the
							third can be derived.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="high" type="PQ_inc">
								<xs:annotation>
									<xs:documentation>
							The high limit of the interval.
							</xs:documentation>
								</xs:annotation>
							</xs:element>
						</xs:choice>
					</xs:sequence>
					<xs:element name="high" type="PQ_inc">
						<xs:annotation>
							<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:sequence>
						<xs:element name="width" type="PQ">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="high" type="PQ_inc" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The high limit of the interval.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:sequence>
						<xs:element name="center" type="PQ">
							<xs:annotation>
								<xs:documentation>
							The arithmetic mean of the interval (low plus high divided by 2). The
							purpose of distinguishing the center as a semantic property is for
							conversions of intervals from and to point values.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="width" type="PQ" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
						The difference between high and low boundary. The purpose of
						distinguishing a width property is to handle all cases of incomplete
						information symmetrically. In any interval representation only two of
						the three properties high, low, and width need to be stated and the
						third can be derived.
						</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SXCM_PQ">
		<xs:complexContent>
			<xs:extension base="PQ">
				<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I">
					<xs:annotation>
						<xs:documentation>
						A code specifying whether the set component is included (union) or
						excluded (set-difference) from the set, or other set operations with
						the current set component and the set as constructed from the
						representation stream up to the current point.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="set_cs_TelecommunicationAddressUse">
		<xs:list itemType="cs_TelecommunicationAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="set_cs_PostalAddressUse">
		<xs:list itemType="cs_PostalAddressUse"/>
	</xs:simpleType>
	<xs:simpleType name="set_cs_EntityNamePartQualifier">
		<xs:list itemType="cs_EntityNamePartQualifier"/>
	</xs:simpleType>
	<xs:simpleType name="set_cs_EntityNameUse">
		<xs:list itemType="cs_EntityNameUse"/>
	</xs:simpleType>
	<xs:complexType name="RTO_QTY_QTY" abstract="true">
		<xs:annotation>
			<xs:appinfo>
				<diff>:RTO_QTY_QTY</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator">
						<xs:annotation>
							<xs:documentation>
						The quantity that is being devided in the ratio.  The default is the
						integer number 1 (one.)
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="QTY"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="denominator">
						<xs:annotation>
							<xs:documentation>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one.)  The denominator must not be zero.
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="QTY"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RTO_MO_PQ">
		<xs:annotation>
			<xs:appinfo>
				<diff>:RTO_MO_PQ</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator">
						<xs:annotation>
							<xs:documentation>
						The quantity that is being devided in the ratio.  The default is the
						integer number 1 (one.)
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="MO"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="denominator">
						<xs:annotation>
							<xs:documentation>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one.)  The denominator must not be zero.
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="PQ"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RTO_PQ_PQ">
		<xs:annotation>
			<xs:appinfo>
				<diff>:RTO_PQ_PQ</diff>
			</xs:appinfo>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="QTY">
				<xs:sequence>
					<xs:element name="numerator">
						<xs:annotation>
							<xs:documentation>
						The quantity that is being devided in the ratio.  The default is the
						integer number 1 (one.)
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="PQ"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:element name="denominator">
						<xs:annotation>
							<xs:documentation>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one.)  The denominator must not be zero.
						</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="PQ"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
		<xs:complexType name="PIVL_TS">
		<xs:sequence>
			<xs:element name="phase" type="IVL_TS" minOccurs="0"/>
			<xs:element name="period" type="PQ" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="alignment" type="cs_CalendarCycle" use="optional"/>
		<xs:attribute name="institutionSpecified" type="bl" use="optional" default="false"/>
		<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="PIVL_PPD_TS">
		<xs:sequence>
			<xs:element name="phase" type="IVL_PPD_TS" minOccurs="0"/>
			<xs:element name="period" type="PPD_PQ" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="alignment" type="cs_CalendarCycle" use="optional"/>
		<xs:attribute name="institutionSpecified" type="bl" use="optional" default="false"/>
		<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="SXCM_PPD_TS">
		<xs:sequence>
			<xs:element name="standardDeviation" type="PQ" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="distributionType" type="cs_ProbabilityDistributionType" use="optional"/>
		<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I"/>
		<xs:attribute name="nullFlavor" type="cs_NullFlavor" use="optional"/>
	</xs:complexType>
	<xs:complexType name="PPD_TS">
		<xs:sequence>
			<xs:element name="standardDeviation" type="PQ" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="distributionType" type="cs_ProbabilityDistributionType" use="optional"/>
		<xs:attribute name="value" type="ts" use="optional"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="PPD_PQ">
		<xs:sequence>
			<xs:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="standardDeviation" type="PQ" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="value" type="real" use="optional"/>
		<xs:attribute name="unit" type="cs" use="optional" default="1"/>
		<xs:attribute name="originalValue" use="optional"/>
		<xs:attribute name="originalUnit" use="optional"/>
		<xs:attribute name="distributionType" type="cs_ProbabilityDistributionType" use="optional"/>
		<xs:attribute name="inclusive" type="bl" use="optional" default="true"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<!-- MS Removed inclusive attribute from high element -->
	<xs:complexType name="IVL_PPD_TS">
		<xs:choice minOccurs="0">
			<xs:sequence>
				<xs:element name="low">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="standardDeviation" type="PQ" minOccurs="0"/>
						</xs:sequence>
						<xs:attribute name="distributionType" type="cs_ProbabilityDistributionType" use="optional"/>
						<xs:attribute name="inclusive" type="bl" use="optional" default="true"/>
					</xs:complexType>
				</xs:element>
				<xs:choice minOccurs="0">
					<xs:element name="width" type="PPD_PQ"/>
					<xs:element name="high" type="PPD_TS"/>
				</xs:choice>
			</xs:sequence>
			<xs:element name="high" type="PPD_TS"/>
			<xs:sequence>
				<xs:element name="width" type="PPD_PQ"/>
				<xs:element name="high" type="PPD_TS"/>
			</xs:sequence>
			<xs:sequence>
				<xs:element name="center" type="PPD_TS"/>
				<xs:element name="width" type="PPD_PQ" minOccurs="0"/>
			</xs:sequence>
		</xs:choice>
		<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="HXIT_PQ" mixed="true">
		<xs:sequence>
			<xs:element name="validTime" type="IVL_TS" minOccurs="0"/>
			<xs:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="value" type="real" use="optional"/>
		<xs:attribute name="unit" type="cs" use="optional" default="1"/>
		<xs:attribute name="originalValue" use="optional"/>
		<xs:attribute name="originalUnit" use="optional"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="SXCM_CD">
		<xs:sequence>
			<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="originalText" type="ED" minOccurs="0"/>
			<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="code" type="cs" use="optional"/>
		<xs:attribute name="codeSystem" type="uid" use="optional"/>
		<xs:attribute name="codeSystemName" type="st" use="optional"/>
		<xs:attribute name="codeSystemVersion" type="st" use="optional"/>
		<xs:attribute name="displayName" type="st" use="optional"/>
		<xs:attribute name="operator" type="cs_SetOperator" use="optional" default="I"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="BXIT_CD">
		<xs:sequence>
			<xs:element name="qualifier" type="CR" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="originalText" type="ED" minOccurs="0"/>
			<xs:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="code" type="cs" use="optional"/>
		<xs:attribute name="codeSystem" type="uid" use="optional"/>
		<xs:attribute name="codeSystemName" type="st" use="optional"/>
		<xs:attribute name="codeSystemVersion" type="st" use="optional"/>
		<xs:attribute name="displayName" type="st" use="optional"/>
		<xs:attribute name="qty" type="int" use="optional" default="1"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="GLIST_TS">
		<xs:sequence>
			<xs:element name="head" type="TS"/>
			<xs:element name="increment" type="PQ"/>
		</xs:sequence>
		<xs:attribute name="period" type="int"/>
		<xs:attribute name="denominator" type="int"/>
		<xs:attribute name="value" type="ts" use="optional"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="GLIST_PQ">
		<xs:sequence>
			<xs:element name="head" type="PQ"/>
			<xs:element name="increment" type="PQ"/>
		</xs:sequence>
		<xs:attribute name="period" type="int"/>
		<xs:attribute name="denominator" type="int"/>
		<xs:attribute name="value" type="real" use="optional"/>
		<xs:attribute name="unit" type="cs" use="optional" default="1"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
	<xs:complexType name="SLIST_PQ">
		<xs:sequence>
			<xs:element name="origin" type="PQ"/>
			<xs:element name="scale" type="PQ"/>
			<xs:element name="digits">
				<xs:simpleType>
					<xs:list itemType="int"/>
				</xs:simpleType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="value" type="real" use="optional"/>
		<xs:attribute name="unit" type="cs" use="optional"/>
		<xs:attributeGroup ref="ANY"/>
	</xs:complexType>
</xs:schema>
